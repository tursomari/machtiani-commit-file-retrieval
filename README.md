# businessmachine-work

Code retieval.

## Example of document retrieval using embeddings

In this example, `cosine_similarity_match_commits.py` will find the most likely matching commit oid based on an example prompt.

### Example setup

Creates `data/commit_logs.json` file

```
poetry run python -m scripts.git_commit_parser_up_to_depth
```


From the project's git history, generate `commits_embeddings.json`:

- [  ] Update as a module so it can use `data/commit_logs.json`

```
poetry run python scripts/embedd_commits.py
```

Build the image.

```
docker build -t businessmachine-work .
```

### Example usage

Find matching text from `commits_embeddings.json`

```
poetry run python scripts/cosine_similarity_match_commits.py
```

## A two-pronged approach

1. A self-hosted api service to generate a summary of a file (e.g. source code) and retrieve the full file by it's name.

2. A self-hosted service that auto-generates commit messages, then indexes them against the hashes of the effected files.

Everything can be in this single project, but really they can be broken up into separate projects if the time comes.

## Strategy 1

More to come.

## Strategy 2

Every commit message is generated by the following:

1. Diff the changes

2. A prompt that asks to give a concise and informative git commit message.

3. Use the answer as the git commit message.

**indexing of commit messages**

You embed and index all commit messages against the effected files.

```
   {
     <commit-message-embedding>: [<files>, ..]
     <commit-message-embedding>: [<files>, ..]
     <commit-message-embedding>: [<files>, ..]
   }
```

**file retrieval**

Embed the prompt, and find related files based on matching `alpha embeddings`.

**answer prompt**

Structure prompt something like this.

```
{pre-prompt}\n{prompt}\n{post-prompt}\n(files}
```

## To do

- [  ] Only embed commits that don't exist in embedd.json  - `scripts/embedd_commits.py`
